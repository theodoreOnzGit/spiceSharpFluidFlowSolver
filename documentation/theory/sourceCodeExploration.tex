
%%%%%%%%%%%%  Generated using docx2latex.com  %%%%%%%%%%%%%%

%%%%%%%%%%%%  v2.0.0-beta  %%%%%%%%%%%%%%

\documentclass[12pt]{article}
\usepackage{amsmath}
\usepackage{latexsym}
\usepackage{amsfonts}
\usepackage[normalem]{ulem}
\usepackage{soul}
\usepackage{array}
\usepackage{amssymb}
\usepackage{extarrows}
\usepackage{graphicx}
\usepackage[backend=biber,
style=apa,
sorting=none,
isbn=true,
doi=true,
url=true,
]{biblatex}\addbibresource{bibliography.bib}

\usepackage{subfig}
\usepackage{wrapfig}
\usepackage{wasysym}
\usepackage{enumitem}
\usepackage{adjustbox}
\usepackage{ragged2e}
\usepackage[svgnames,table]{xcolor}
\usepackage{tikz}
\usepackage{longtable}
\usepackage{changepage}
\usepackage{setspace}
\usepackage{hhline}
\usepackage{multicol}
\usepackage{tabto}
\usepackage{float}
\usepackage{multirow}
\usepackage{makecell}
\usepackage{fancyhdr}
\usepackage[toc,page]{appendix}
\usepackage[hidelinks]{hyperref}
\usetikzlibrary{shapes.symbols,shapes.geometric,shadows,arrows.meta}
\tikzset{>={Latex[width=1.5mm,length=2mm]}}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\TabPositions{0.5in,1.0in,1.5in,2.0in,2.5in,3.0in,3.5in,4.0in,4.5in,5.0in,5.5in,6.0in,}

\urlstyle{same}

\renewcommand{\_}{\kern-1.5pt\textunderscore\kern-1.5pt}

 %%%%%%%%%%%%  Set Depths for Sections  %%%%%%%%%%%%%%

% 1) Section
% 1.1) SubSection
% 1.1.1) SubSubSection
% 1.1.1.1) Paragraph
% 1.1.1.1.1) Subparagraph


\setcounter{tocdepth}{5}
\setcounter{secnumdepth}{5}


 %%%%%%%%%%%%  Set Depths for Nested Lists created by \begin{enumerate}  %%%%%%%%%%%%%%


\setlistdepth{9}
\renewlist{enumerate}{enumerate}{9}
		\setlist[enumerate,1]{label=\arabic*)}
		\setlist[enumerate,2]{label=\alph*)}
		\setlist[enumerate,3]{label=(\roman*)}
		\setlist[enumerate,4]{label=(\arabic*)}
		\setlist[enumerate,5]{label=(\Alph*)}
		\setlist[enumerate,6]{label=(\Roman*)}
		\setlist[enumerate,7]{label=\arabic*}
		\setlist[enumerate,8]{label=\alph*}
		\setlist[enumerate,9]{label=\roman*}

\renewlist{itemize}{itemize}{9}
		\setlist[itemize]{label=$\cdot$}
		\setlist[itemize,1]{label=\textbullet}
		\setlist[itemize,2]{label=$\circ$}
		\setlist[itemize,3]{label=$\ast$}
		\setlist[itemize,4]{label=$\dagger$}
		\setlist[itemize,5]{label=$\triangleright$}
		\setlist[itemize,6]{label=$\bigstar$}
		\setlist[itemize,7]{label=$\blacklozenge$}
		\setlist[itemize,8]{label=$\prime$}

\setlength{\topsep}{0pt}\setlength{\parskip}{8.04pt}
\setlength{\parindent}{0pt}

 %%%%%%%%%%%%  This sets linespacing (verticle gap between Lines) Default=1 %%%%%%%%%%%%%%


\renewcommand{\arraystretch}{1.3}


%%%%%%%%%%%%%%%%%%%% Document code starts here %%%%%%%%%%%%%%%%%%%%
\begin{document}

\tableofcontents

\part{Problem statement}

Pipe networks can be analogous to Electrical Circuits. Therefore, it can be tempting to use electrical flow solvers for pipe networks.

\section{Unit Comparison}

Voltage is energy per unit charge unit wise. $\frac{J}{C}$ Joules per coulomb.

Whereas Pressure can be thought of as Energy per unit volume. $\frac{J}{m^3}$ Joules per meter cubed. That would be the unit of pascals.

$$(workDone)\ Joules = (pressure)\ Pa * (volume)\ m^3$$
$$(pressure)\ Pa = \frac{(workDone)\ Joules}{(volume)\ m^3}$$

Compare this to voltage:

$$(voltage)\ Volts = \frac{(workDone)\ Joules}{(Charge)\ Coulomb}$$

Likewise for volumetric flowrate, this is

$$(flowrate)\ m^3/s = \frac{(vol)\ m^3}{(time)\ s}$$

And for current,

$$(current)\ C/s = \frac{(Charge)\ Coulomb}{(time)\ s}$$

\section{nonlinearities in flow resistance}

However, the components exhibiting flow resistance often do not obey Ohm's law.

$$electrical\ resistance\ (\Omega) = \frac{V\ (Volts)}{I\ (Ampere)}$$
$$flow\ resistance = \frac{\Delta P\ (Pa)}{\dot{V}\ (m^3)}$$


For ohm's law, the ratio V/I reduces to a constant, but flow resistance often reduces to some expression. 

If we were to use Fanning friction factor for pipe (cite perry's handbook)

$$f = \frac{\Delta P}{ (\frac{4L}{D}) \  \frac{1}{2} \rho u^2 }$$

$$\Delta P = f  (\frac{4L}{D}) \  \frac{1}{2} \rho u^2 $$

In Perry's chemical engineering handbook, the formula used for fanning's friction factor by Churchill is:

$$f = 2 \left[\\
\left( \frac{8}{Re} \right)^{12} + \\
\left( \frac{1}{A+B}\right)^{3/2} \\
\right]^{1/12} $$
 
Where:

$$A = \left[ 2.457 \ln \frac{1}{\left( \frac{1}{(7/Re)^{0.9}} + \\
0.27 \frac{\varepsilon}{D} \right)} \\
\right]\ \ ; \ \ \\
B = \left( \frac{37530}{Re} \\ 
\right)^{16} $$


$$Re = \frac{ux}{\nu} = \frac{\dot{V} x}{A_{XS} \nu}$$

Where $A_{XS}$ represents cross sectional area.
We can see that this is strongly non linear with respect to volumetric flowrate.
abcde

\part{Newton Raphson method for Nonlinear Equations}

\section{one equation example of Newton Raphson}
We want to solve if we have some equation y=f(x)

$$f(x)=0$$

We are going to make use of derivatives to help us get there:

We do a first order Taylor series approximation of derivatives

$$\frac{d f(x)}{dx} = \frac{f(x + \Delta x) - f(x)}{\Delta x}$$

we want to make it such that:

$$f(x + \Delta x) \approx 0$$

So we have this:

$$f(x) >> f(x+\Delta x)$$

$$\frac{d f(x)}{dx} = \frac{ - f(x)}{\Delta x}$$

$$\frac{d f(x)}{dx} = \frac{ - f(x)}{\Delta x}$$

Solve for $\Delta x$:

$$\Delta x = \frac{ - f(x)}{\frac{d f(x)}{dx}}$$

Once we solve for $\Delta x$, we can update:

$$f(x_{i+1}) = f(x + \Delta x) $$

and repeat the method after we solve for $f(x_{i+1})$
\section{Newton Raphson for multiple equations}

$$f_1 (x_1 ,x_2, x_3) = 0$$
$$f_2 (x_1 ,x_2, x_3) = 0$$
$$f_3 (x_1 ,x_2, x_3) = 0$$

We need derivatives as well if we want to solve above system of eqns:

$$df_1 = f_1 (x_1+\Delta x_1,x_2+\Delta x_2 , x_3+\Delta x_3) - f_1 (x_1,x_2,x_3)$$

Let's expand the LHS:

$$df_1 = \frac{\partial f_1}{\partial x_1} \Delta x_1 + \frac{\partial f_1}{\partial x_2} \Delta x_2 + \frac{\partial f_1}{\partial x_3} \Delta x_3$$

$$\frac{\partial f_1}{\partial x_1} \Delta x_1 + \frac{\partial f_1}{\partial x_2} \Delta x_2 + \frac{\partial f_1}{\partial x_3} \Delta x_3 = f_1 (x_1+\Delta x_1,x_2+\Delta x_2 , x_3+\Delta x_3) - f_1 (x_1,x_2,x_3)$$

We need to do this for $f_2$ and $f_3 $ as well:

$$\frac{\partial f_2}{\partial x_1} \Delta x_1 + \frac{\partial f_2}{\partial x_2} \Delta x_2 + \frac{\partial f_2}{\partial x_3} \Delta x_3 = f_2 (x_1+\Delta x_1,x_2+\Delta x_2 , x_3+\Delta x_3) - f_2 (x_1,x_2,x_3)$$

$$\frac{\partial f_3}{\partial x_1} \Delta x_1 + \frac{\partial f_3}{\partial x_2} \Delta x_2 + \frac{\partial f_3}{\partial x_3} \Delta x_3 = f_3 (x_1+\Delta x_1,x_2+\Delta x_2 , x_3+\Delta x_3) - f_3 (x_1,x_2,x_3)$$


Let's write this in matrix form

$$ \begin{bmatrix}
\frac{\partial f_1}{\partial x_1}  & \frac{\partial f_1}{\partial x_2}  & \frac{\partial f_1}{\partial x_3} \\
\frac{\partial f_2}{\partial x_1}  & \frac{\partial f_2}{\partial x_2}  & \frac{\partial f_2}{\partial x_3} \\
\frac{\partial f_3}{\partial x_1}  & \frac{\partial f_3}{\partial x_2}  & \frac{\partial f_3}{\partial x_3} 
\end{bmatrix} \\ 
\begin{bmatrix}
\Delta x_1 \\
\Delta x_2 \\
\Delta x_3
\end{bmatrix} = \\
\begin{bmatrix}
f_1 (x_1+\Delta x_1,x_2+\Delta x_2 , x_3+\Delta x_3) \\
f_2 (x_1+\Delta x_1,x_2+\Delta x_2 , x_3+\Delta x_3) \\
f_3 (x_1+\Delta x_1,x_2+\Delta x_2 , x_3+\Delta x_3)
\end{bmatrix} - \\
\begin{bmatrix}
f_1 (x_1,x_2,x_3) \\
f_2 (x_1,x_2,x_3) \\
f_3 (x_1,x_2,x_3)
\end{bmatrix}
$$

Again, we need to approx:

$$\begin{bmatrix}
f_1 (x_1+\Delta x_1,x_2+\Delta x_2 , x_3+\Delta x_3) \\
f_2 (x_1+\Delta x_1,x_2+\Delta x_2 , x_3+\Delta x_3) \\
f_3 (x_1+\Delta x_1,x_2+\Delta x_2 , x_3+\Delta x_3)
\end{bmatrix} \approx \vec{0}$$

And we just solve:

$$ \begin{bmatrix}
\frac{\partial f_1}{\partial x_1}  & \frac{\partial f_1}{\partial x_2}  & \frac{\partial f_1}{\partial x_3} \\
\frac{\partial f_2}{\partial x_1}  & \frac{\partial f_2}{\partial x_2}  & \frac{\partial f_2}{\partial x_3} \\
\frac{\partial f_3}{\partial x_1}  & \frac{\partial f_3}{\partial x_2}  & \frac{\partial f_3}{\partial x_3} 
\end{bmatrix} \\ 
\begin{bmatrix}
\Delta x_1 \\
\Delta x_2 \\
\Delta x_3
\end{bmatrix} = \\
-\begin{bmatrix}
f_1 (x_1,x_2,x_3) \\
f_2 (x_1,x_2,x_3) \\
f_3 (x_1,x_2,x_3)
\end{bmatrix}
$$

We shall say that the Jacobian matrix is:
$$ \vec{J} = \begin{bmatrix}
\frac{\partial f_1}{\partial x_1}  & \frac{\partial f_1}{\partial x_2}  & \frac{\partial f_1}{\partial x_3} \\
\frac{\partial f_2}{\partial x_1}  & \frac{\partial f_2}{\partial x_2}  & \frac{\partial f_2}{\partial x_3} \\
\frac{\partial f_3}{\partial x_1}  & \frac{\partial f_3}{\partial x_2}  & \frac{\partial f_3}{\partial x_3} 
\end{bmatrix}$$

We need to find the inverse in order to solve the above equation

$$\vec{J}^{-1}$$

So that we can find:

$$  
\begin{bmatrix}
\Delta x_1 \\
\Delta x_2 \\
\Delta x_3
\end{bmatrix} = - \vec{J}^{-1} \\
\begin{bmatrix}
f_1 (x_1,x_2,x_3) \\
f_2 (x_1,x_2,x_3) \\
f_3 (x_1,x_2,x_3)
\end{bmatrix}
$$

Once we find $\vec{\Delta x}$, we can update the values:

$$\vec{\Delta x} = \begin{bmatrix}
\Delta x_1 \\
\Delta x_2 \\
\Delta x_3
\end{bmatrix}$$
This is the part where we find the next iteration

$$\overrightarrow{x_{i+1}} = \overrightarrow{x_i} + \overrightarrow{\Delta x}$$

$$\overrightarrow{x_i} = \begin{bmatrix}
x_{1(i)} \\
x_{2(i)} \\
x_{3(i)}
\end{bmatrix} $$

$$\overrightarrow{x_{i+1}} = \begin{bmatrix}
x_{1(i+1)} \\
x_{2(i+1)} \\
x_{3(i+1)}
\end{bmatrix} $$

Keep substituting until the solution is found within tolerance.

\part{How are Matrices Constructed}


\url{https://spicesharp.github.io/SpiceSharp/articles/structure/flow.html}

The Y-matrix (Jacobian) and the RHS matrix: \textbf{$-F(x^{(k)}) + J(x^{(k)}) \bullet x^{(k)}$}

\url{https://spicesharp.github.io/SpiceSharp/articles/custom_components/modified_nodal_analysis.html}

This is done in the IBiasingBehaviour: "contains methods that are called each iteration in order to build up the Y-matrix and right-hand side vector."

\url{https://spicesharp.github.io/SpiceSharp/articles/structure/flow.html}

IBehaviour is found here:

\url{https://github.com/SpiceSharp/SpiceSharp/tree/master/SpiceSharp/Simulations/Behaviors}

IBiasingBehaviour is found here:

\url{https://github.com/SpiceSharp/SpiceSharp/tree/dace7bddaadf7ac22bc32abd2dc61b4d28afb13d/SpiceSharp/Simulations/Base/Biasing}



\part{Matrix Solvers}
Note we are solving for (in a 3x3 matrix case):

$$ \begin{bmatrix}
\frac{\partial f_1}{\partial x_1}  & \frac{\partial f_1}{\partial x_2}  & \frac{\partial f_1}{\partial x_3} \\
\frac{\partial f_2}{\partial x_1}  & \frac{\partial f_2}{\partial x_2}  & \frac{\partial f_2}{\partial x_3} \\
\frac{\partial f_3}{\partial x_1}  & \frac{\partial f_3}{\partial x_2}  & \frac{\partial f_3}{\partial x_3} 
\end{bmatrix} \\ 
\begin{bmatrix}
\Delta x_1 \\
\Delta x_2 \\
\Delta x_3
\end{bmatrix} = \\
-\begin{bmatrix}
f_1 (x_1,x_2,x_3) \\
f_2 (x_1,x_2,x_3) \\
f_3 (x_1,x_2,x_3)
\end{bmatrix}
$$

We rewrite this as:

$$ \begin{bmatrix}
\frac{\partial f_1}{\partial x_1}  & \frac{\partial f_1}{\partial x_2}  & \frac{\partial f_1}{\partial x_3} \\
\frac{\partial f_2}{\partial x_1}  & \frac{\partial f_2}{\partial x_2}  & \frac{\partial f_2}{\partial x_3} \\
\frac{\partial f_3}{\partial x_1}  & \frac{\partial f_3}{\partial x_2}  & \frac{\partial f_3}{\partial x_3} 
\end{bmatrix} \\ 
\begin{bmatrix}
\ x_1^{(k+1)} - x_1^{(k)} \\
\ x_2^{(k+1)} - x_2^{(k)}\\
\ x_3^{(k+1)} - x_3^{(k)}
\end{bmatrix} = \\
-\begin{bmatrix}
f_1 (x_1,x_2,x_3) \\
f_2 (x_1,x_2,x_3) \\
f_3 (x_1,x_2,x_3)
\end{bmatrix}
$$

$$ \begin{bmatrix}
\frac{\partial f_1}{\partial x_1}  & \frac{\partial f_1}{\partial x_2}  & \frac{\partial f_1}{\partial x_3} \\
\frac{\partial f_2}{\partial x_1}  & \frac{\partial f_2}{\partial x_2}  & \frac{\partial f_2}{\partial x_3} \\
\frac{\partial f_3}{\partial x_1}  & \frac{\partial f_3}{\partial x_2}  & \frac{\partial f_3}{\partial x_3} 
\end{bmatrix} \\ 
\begin{bmatrix}
\ x_1^{(k+1)}  \\
\ x_2^{(k+1)} \\
\ x_3^{(k+1)} 
\end{bmatrix} = \\
-\begin{bmatrix}
f_1 (x_1,x_2,x_3) \\
f_2 (x_1,x_2,x_3) \\
f_3 (x_1,x_2,x_3)
\end{bmatrix} + \\
\begin{bmatrix}
\frac{\partial f_1}{\partial x_1}  & \frac{\partial f_1}{\partial x_2}  & \frac{\partial f_1}{\partial x_3} \\
\frac{\partial f_2}{\partial x_1}  & \frac{\partial f_2}{\partial x_2}  & \frac{\partial f_2}{\partial x_3} \\
\frac{\partial f_3}{\partial x_1}  & \frac{\partial f_3}{\partial x_2}  & \frac{\partial f_3}{\partial x_3} 
\end{bmatrix} \\
\begin{bmatrix}
\ x_1^{(k)} \\
\ x_2^{(k)}\\
\ x_3^{(k)}
\end{bmatrix}
$$

Note, that the Ymatrix or Jacobian will be evaulated at \textbf{$\overrightarrow{x^{(k)}}$}. We substitute all the partial derivatives in the Jacobian with the x values at the current iteration. And these all become constants for that iteration.


These are found under:
\url{https://github.com/SpiceSharp/SpiceSharp/tree/master/SpiceSharp/Algebra}

So once we have our Jacobians, the matrix solver takes care of the rest.
So the inversion of the Jacobian (Y matrix), and matrix multiplication are taken care of by these solvers.

Now let's say we want to solve a matrix, where we have a Y matrix and a RHS vector.

How do we put them into a class?

\section{Where the Y matrix is defined}

Each solver class, eg. SparseRealSolver

\url{https://github.com/SpiceSharp/SpiceSharp/blob/dace7bddaadf7ac22bc32abd2dc61b4d28afb13d/SpiceSharp/Algebra/Solve/LU/SparseSolver/SparseRealSolver.cs}

\url{https://spicesharp.github.io/SpiceSharp/api/SpiceSharp.Algebra.SparseRealSolver.html}

will have a way of setting the matrix.

For example,

under the sparseSolverTests

\url{https://github.com/SpiceSharp/SpiceSharp/blob/dace7bddaadf7ac22bc32abd2dc61b4d28afb13d/SpiceSharpTest/Algebra/SparseSolverTests.cs}

from line 43-72, 

\subsection{setting matrices and RHS vector values within the solver}

we can clearly see a matrix and rhs being defined for us.

the matrix there is just a array of array of doubles. Whereas the rhs vector is simply an array of doubles. 

The Solver.GetElement method will modify the matrix within the solver object if a row and column is supplied.

And the Solver.GetElement method will modify the RHS vector within the solver object if a row value is supplied.

GetElement methods are defined in SparseLUSolver.cs, and two overloads are given. One gets the element of the matrix within the solver, one gets the vector.

Both of these return Element<T>, and this class represents the properties of elements within matrices and vectors.

\subsection{getting no. of equations within the solver}

The solver.size represents the number of equations represented by the matrix

\url{https://spicesharp.github.io/SpiceSharp/api/SpiceSharp.Algebra.SparseRealSolver.html}

The sparseRealSolver inherits from sparseLUSolver which in turn inherits from pivotingSolver.

\url{https://github.com/SpiceSharp/SpiceSharp/blob/dace7bddaadf7ac22bc32abd2dc61b4d28afb13d/SpiceSharp/Algebra/Solve/PivotingSolver.cs}

the pivoting solver in turn defines the size property. Which returns the maximum value of the size of the matrix and size of the vector (which is the RHS vector).

The size attribute is defined in the constructor

\url{https://github.com/SpiceSharp/SpiceSharp/blob/dace7bddaadf7ac22bc32abd2dc61b4d28afb13d/SpiceSharp/Algebra/Matrix/SparseMatrix/SparseMatrix.cs}

At least for the sparseMatrix.cs, we can see that these matrices are necessarily square matrices from line 75-94 of SpiceSharp/Algebra/Matrix/SparseMatrix/SparseMatrix.cs

The same size attribute is used to defined \textbf{both} rows and columns of the matrices. This defines the matrix size.

A similar process can be said for the vector:

/SpiceSharp/Algebra/Vector/SparseVector/SparseVector.cs

in lines 54-59.

We can see that getting the maximum value of the size and vectors will get us the number of equations.

What if they weren't the same?

It should be apparent that an error should occur.

But that is kind of an exception than the norm. Shouldn't happen if we define our matrices and vectors properly.

\subsection{Sparse vs Dense Vectors or Matrices}

Sparse vectors or Matrices have most of their elements set to zero.

Why do we have different classes for sparse vectors and dense vectors? Likely their solving strategies may be different.

\subsection{Solving the system of equations with Ymatrix and RHS vector}

see line 174-234 of


\url{https://github.com/SpiceSharp/SpiceSharp/blob/dace7bddaadf7ac22bc32abd2dc61b4d28afb13d/SpiceSharpTest/Algebra/SparseSolverTests.cs}

\begin{itemize}
\item (1) define RHS and Y vector using for loops
\item (2) OrderAndFactor
\item (3) create a new solution vector
\item (4) feed solution vector into solver.Solve() method
\item (5) check the solution vector
\end{itemize}


\part{Simulation Algorithm}

This is taken care of by ISimulation

\url{https://spicesharp.github.io/SpiceSharp/articles/structure/flow.html}
\url{https://github.com/SpiceSharp/SpiceSharp/tree/master/SpiceSharp/Simulations}


\part{Matrices}

$$\begin{bmatrix}
1 & 2 & 3 \\
a & b & c
\end{bmatrix}$$

 
\end{document}
